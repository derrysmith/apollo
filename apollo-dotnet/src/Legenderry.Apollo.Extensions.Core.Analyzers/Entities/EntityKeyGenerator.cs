using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Legenderry.Apollo.Extensions.Core.Entities;

[Generator]
internal class EntityKeyGenerator : IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		var entityKeyAttributeType = typeof(EntityKeyAttribute);
		var entityKeyAttributeName = entityKeyAttributeType.FullName
									 ?? $"{entityKeyAttributeType.Namespace}.{nameof(EntityKeyAttribute)}";

		// generate code for all types that are marked with EntityKeyAttribute
		var entityKeys = context.SyntaxProvider.ForAttributeWithMetadataName(
			entityKeyAttributeName,
			predicate: static (_, _) => true,
			transform: TransformEntityKey);

		// register output for entity keys
		context.RegisterSourceOutput(entityKeys, GenerateEntityKeySourceCode);
	}

	private static EntityKeyMetadata? TransformEntityKey(GeneratorAttributeSyntaxContext ctx, CancellationToken ct)
	{
		if (ctx.SemanticModel.GetDeclaredSymbol(ctx.TargetNode) is not INamedTypeSymbol symbol)
			return null;

		var fileName   = symbol.ToString();
		var typeName   = symbol.Name;
		var @namespace = symbol.ContainingNamespace.ToString();

		var entityKeyAttribute = ctx.Attributes.First(data =>
			data.AttributeClass?.Name == nameof(EntityKeyAttribute));

		var prefix = entityKeyAttribute.NamedArguments.FirstOrDefault(kvp =>
			kvp.Key == nameof(EntityKeyAttribute.Prefix)).Value.Value?.ToString() ?? string.Empty;
		var suffix = entityKeyAttribute.NamedArguments.FirstOrDefault(kvp =>
			kvp.Key == nameof(EntityKeyAttribute.Suffix)).Value.Value?.ToString() ?? string.Empty;

		return new EntityKeyMetadata(fileName, typeName, @namespace, prefix, suffix);
	}

	private static void GenerateEntityKeySourceCode(SourceProductionContext spc, EntityKeyMetadata? model)
	{
		// abort code generation if model is null/empty
		if (model is null) return;

		var sb = new StringBuilder();

		// file header
		var headerSourceCode = "// <auto-generated />";

		// using declarations
		var usingsSourceCode = $@"
using System;
using System.Text.Json;
using System.Text.Json.Serialization;
using {typeof(EntityKeyAttribute).Namespace};
";
		
		// entity key type declaration
		var entityKeySourceCode = $@"
namespace {model.Namespace}
{{
	[JsonConverter(typeof({model.TypeName}JsonConverter))]
	public readonly partial record struct {model.TypeName} : {typeof(IEntityKey).FullName}
	{{
		private static readonly EntityKeyValueGenerator Generator;
		private static readonly EntityKeyValueFormatter Formatter;
		private static readonly EntityKeyValueExtractor Extractor;

		private readonly string _value;

		static {model.TypeName}()
		{{
			{model.TypeName}.Generator = () => Ulid.NewUlid().ToString();
			{model.TypeName}.Formatter = value => $""{model.Prefix}{{value}}{model.Suffix}"";
			{model.TypeName}.Extractor = value => EntityKeyExtensions.ExtractEntityKeyValue(value, ""{model.Prefix}"", ""{model.Suffix}"");
		}}

		private {model.TypeName}(string value)
			=> _value = value;

		public static {model.TypeName} New()
			=> new {model.TypeName}({model.TypeName}.Generator());

		public static {model.TypeName} Parse(string value)
		{{
			if ({model.TypeName}.TryParse(value, out var entityKey))
				return entityKey;

			throw new System.ArgumentException($""Cannot parse '{{value}}' into type {model.TypeName}."", nameof(value));
		}}

		public static {model.TypeName} Parse(Guid value)
		{{
			if ({model.TypeName}.TryParse(value, out var entityKey))
				return entityKey;

			throw new System.ArgumentException($""Cannot parse '{{value}}' into type {model.TypeName}."", nameof(value));
		}}

		public static bool TryParse(string value, out {model.TypeName} entityKey)
		{{
			// extract raw value from specified value
			var entityKeyValue = {model.TypeName}.Extractor(value);

			if (Ulid.TryParse(entityKeyValue, out var ulid))
			{{
				entityKey = new {model.TypeName}(ulid.ToString());
				return true;
			}}

			if (Guid.TryParse(entityKeyValue, out var guid))
			{{
				entityKey = new {model.TypeName}(new Ulid(guid).ToString());
				return true;
			}}

			entityKey = default;
			return false;
		}}

		public static bool TryParse(Guid value, out {model.TypeName} entityKey)
		{{
			entityKey = new {model.TypeName}(new Ulid(value).ToString());
			return true;
		}}

		public override string ToString()
			=> {model.TypeName}.Formatter(_value);
	}}
}}
";

		// json converter type declaration
		var jsonConverterSourceCode = $@"
namespace {model.Namespace}
{{
	public class {model.TypeName}JsonConverter : JsonConverter<{model.TypeName}>
	{{
		public override {model.TypeName} Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
			=> {model.TypeName}.Parse(reader.GetString());

		public override void Write(Utf8JsonWriter writer, {model.TypeName} value, JsonSerializerOptions options)
			=> writer.WriteStringValue(value.ToString());
	}}
}}
";
		
		sb.AppendLine(headerSourceCode);
		sb.Append(usingsSourceCode);
		sb.Append(entityKeySourceCode);
		sb.Append(jsonConverterSourceCode);

		spc.AddSource($"{model.FileName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
	}
}